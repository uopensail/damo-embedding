//
// `Damo-Embedding` - 'c++ tool for sparse parameter server'
// Copyright (C) 2019 - present timepi <timepi123@gmail.com>
// `Damo-Embedding` is provided under: GNU Affero General Public License
// (AGPL3.0) https://www.gnu.org/licenses/agpl-3.0.html unless stated otherwise.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//

#ifndef PY_DAMO_H_
#define PY_DAMO_H_

#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>

#include <memory>
#include <string>

#include "embedding.h"

namespace py = pybind11;

/**
 * @brief Python binding interface for Damo embedding
 *
 * This class provides Python-accessible operations for managing and interacting
 * with embedding warehouses. It wraps native C++ implementation using pybind11
 * for seamless integration with Python machine learning workflows.
 */
class PyDamo {
 public:
  PyDamo() = delete;

  /**
   * @brief Constructs a new PyDamo instance from configuration
   * @param config_file Path to JSON configuration file
   * @throws py::value_error If configuration is invalid or file not found
   *
   * Example configuration:
   * @code{.json}
   * {
   *   "embeddings": [
   *     {
   *       "group": 0,
   *       "dim": 128,
   *       "initializer": {"name": "xavier"},
   *       "optimizer": {"name": "adamw", ...}
   *     }
   *   ],
   *   "dir": "/path/to/rocksdb",
   *   "ttl": 864000
   * }
   * @endcode
   */
  explicit PyDamo(const std::string& config_file);
  ~PyDamo() = default;

  /**
   * @brief Dumps embeddings to binary file format
   * @param path Output file path
   *
   * File format:
   * - int32: num_embedding_groups
   * - int32[num_groups]: group_ids
   * - int32[num_groups]: group_dims
   * - int64[num_groups]: group_counts
   * - Repeated records:
   *   - int64: key
   *   - int32: group
   *   - float[dim]: embedding_values
   */
  void dump(const std::string& path) { warehouse_->dump(path); }

  /**
   * @brief Creates a full snapshot of current embeddings
   * @param path Output file path for checkpoint
   * @throws py::value_error If:
   *         - File path is inaccessible
   *         - Database operation fails
   *
   * Checkpoint format:
   * - Header: int64_t total_records
   * - Repeated records:
   *   - size_t key_length
   *   - byte[key_length] key_data
   *   - size_t value_length
   *   - byte[value_length] value_data
   */
  void checkpoint(const std::string& path) { warehouse_->checkpoint(path); }

  /**
   * @brief Loads embeddings from a checkpoint file and replaces current state
   * @param path Path to the checkpoint file created by CreateCheckpoint()
   * @throws py::value_error For:
   *         - Invalid or inaccessible file path
   *         - Corrupted checkpoint format
   *         - Database operation failures
   * @warning This operation will completely overwrite current embeddings
   *
   * Checkpoint format requirements:
   * - Must be generated by companion CreateCheckpoint() method
   * - File header: int64_t record_count
   * - Followed by sequential records:
   *   - size_t key_size (bytes)
   *   - byte[key_size] key_data
   *   - size_t value_size (bytes)
   *   - byte[value_size] value_data
   *
   * Operation flow:
   * 1. Clears all existing embeddings
   * 2. Batch loads records from checkpoint
   * 3. Performs full database compaction
   *
   * Memory considerations:
   * - For large checkpoints (>1GB), ensure sufficient memory is available
   * - Temporary buffers may allocate 2x file size during loading
   *
   * Example usage:
   * @code{.py}
   * # Create and load checkpoint
   * damo.checkpoint("backup.chk")
   * damo.load("backup.chk")  # Restores to this state
   * @endcode
   *
   * @note
   * - Atomic operation: Either fully succeeds or leaves warehouse unchanged
   * - Not thread-safe: Ensure no concurrent operations during loading
   */
  void load(const std::string& path) { warehouse_->load(path); }

  /**
   * @brief Retrieves embedding weights for specified keys
   * @param group Target embedding group index (0-based)
   * @param keys 1D array of embedding keys (int64)
   * @param[out] weights 1D output array for weights (float)
   * @throws py::value_error For:
   *         - Invalid group index
   *         - Non-writable weights array
   *         - Dimension mismatch
   *         - Uninitialized warehouse
   *
   * Example usage:
   * @code{.py}
   * keys = np.array([123, 456], dtype=np.int64)
   * weights = np.empty(2 * 128, dtype=np.float32)  # dim=128
   * damo.pull(0, keys, weights)
   * @endcode
   */
  void pull(int group, py::array_t<int64_t> keys, py::array_t<float> weights);

  /**
   * @brief Applies gradients to specified embeddings
   * @param group Target embedding group index (0-based)
   * @param keys 1D array of embedding keys (int64)
   * @param gradients 1D array of gradient values (float)
   * @throws py::value_error For:
   *         - Invalid group index
   *         - Empty keys array
   *         - Dimension mismatch
   *         - Uninitialized warehouse
   *
   * Gradient array should have size: len(keys) * embedding_dimension
   */
  void push(int group, py::array_t<int64_t> keys, py::array_t<float> gradients);

  /**
   * @brief Serializes current warehouse state to JSON
   * @return JSON string representation of warehouse configuration
   * @throws py::value_error If serialization fails
   */
  std::string to_json() const { return warehouse_->to_json(); }

 private:
  std::shared_ptr<embedding::EmbeddingWarehouse>
      warehouse_;  // Fixed class name
};

#endif  // PY_DAMO_H_